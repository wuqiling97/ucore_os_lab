# Lab2

## 知识点

本实验涉及到了以下课程上提到的知识点：

1.  连续内存分配的最先匹配策略
2.  x86分页机制
3.  二级页表

本实验涉及的其他知识点：

1.  通用链表的实现
2.  C语言的各种magic的宏定义

OS原理中很重要，但在实验中没有对应上的知识点：

1.  连续内存分配的最优匹配、最差匹配
2.  内存碎片整理

## 练习1

**实现 first-fit 连续物理内存分配算法**

实验代码已经实现了某种内存分配算法，为了实现首次分配，需要维护free_list链表使其具有以下性质：

1.  链表中的page block均为空闲
2.  链表中的page block地址需要升序排列

因此需要对一下函数做出修改

#### default_init_memmap

由于 `page_init` 在调用该函数时，传入的base地址是从小到大的，所以需要将list_add修改为list_add_before，来确保用list_next访问Page时，地址是从小到大的

#### default_alloc_pages

参考注释，补全原先代码中缺少的设置即可。也就是要设置分裂出的Page的flags的property bit为1；此外，在把分裂出的Page加入链表中时，需要插入在最先匹配找到的Page后面，为此，需要把 `list_del(&(page->page_link));` 挪到后面。

在对比答案之后，我发现答案没有 `SetPageReserved(page);` ，但是注释4.1.2却提到“Some flag bits of this page should be set as the following: `PG_reserved = 1`, `PG_property = 0`.”，因此怀疑注释有误。

#### default_free_pages

需要在合并相邻块完成之后，在链表中确定正确的插入位置，而不是像原始代码一样直接放在free_list的后面。为此，我添加了一个循环来查找，并且把合并块插入正确的位置。

#### 改进的空间

1.  释放Page函数中，在合并块的时候就可以确定要插入的正确位置，因此可以省下 `default_free_pages` 当中的第二个循环。
2.  释放的合并操作中，查找下一个相邻的空闲块的时候不必循环，只需要根据当前Page地址+页面数即可获取下一个Page地址，然后可尝试合并。
3.  释放的合并操作中，如果在空闲块的最后一个块上也记录空闲块的数目，那么在查找上一个相邻空闲块时也不必循环，只需要根据当前Page地址，获取上一Page地址，获取上一Page所属的空闲大块的数目，然后计算出空闲块的首地址，即可尝试合并。

## 练习2

**实现寻找虚拟地址对应的页表项**

首先根据 `la` 在页目录表中获得页目录项，如果项存在，就直接根据其中记录的信息返回页表项地址。否则，如果 create=true，并且page分配成功，就设置相应的信息，然后修改页目录项的值。

**请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。**

页目录项的结构如下

```
 31               12 11 9 8 7 6 5 4 3 2 1 0
+-------------------+----+-+-+-+-+-+-+-+-+-+
|   页表基址高20位   |忽略 |G|S|0|A|C|T|U|W|P|
+-------------------+----+-+-+-+-+-+-+-+-+-+
```

-   G：对页目录项无用
-   S：表示页大小，1代表4MB，0代表4DB
-   A：在上次清零后，该项是否被访问过，对于页替换算法有用
-   C：是否允许缓存
-   T：缓存是否write through
-   U：能否被用户态访问
-   W：页是否可写
-   P：页表是否位于内存中

页表项的结构如下

```
 31               12 11 9 8 7 6 5 4 3 2 1 0
+-------------------+----+-+-+-+-+-+-+-+-+-+
|   页基地址高20位   |忽略 |G|0|D|A|C|T|U|W|P|
+-------------------+----+-+-+-+-+-+-+-+-+-+
```

-   G：这一页表项是否是全局项，若为1，在CR3改变时，TLB不被清除
-   D：与页目录项的A相似
-   P：页面是否位于内存中
-   其余的项含义相同

**如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？**

CPU会将异常的线性地址保存在CR2寄存器中，然后查询IDT找到中断服务程序入口点。由于当前已在内核态，不涉及特权级的变化，处理器还会向当前栈中压入cs、eip和错误码。错误码记录了异常的一些标志，比如是读还是写操作触发了异常，是非法访问还是缺页触发了异常，这对于页替换算法和写时复制的实现都有用。最后，跳转至中断服务程序。这些事情中间还会做权限检查，不通过还会触发保护错误。这些事情执行的顺序可能与处理器实现有关。

## 练习3

**释放某虚地址所在的页并取消对应二级页表项的映射**

如果页表项存在，那么将对应的Page结构的引用-1，并且清除页表项（二级页表），最后将对应的TLB设置为无效。

**数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？**

有，Page可以通过宏 `page2pa` 转换为物理地址，然后用来填写页目录项或页表项；页目录项或页表项的高20位都是物理地址（页号），可以作为索引找到对应的Page结构体。

**如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？**

在Lab2中，由于地址映射的建立分为多个阶段完成，所以针对不同的阶段需要修改不同的代码以使得虚拟地址和物理地址相等。

1.  Bootloader阶段，线性地址与物理地址相等，无需修改；
2.  从`kern_entry`到`enable_paging`函数，主要采用段机制进行地址映射，需要修改的地方为`init/entry.S`中的gdt表项，去除`KERNBASE`有关的定义。此外，还需要修改ucore的链接脚本，将ucore起始的虚拟地址由`0xC0100000`改为`0x00100000`。
3.  从`enable_paging`函数开始到`gdt_init`函数，虽然启动了页机制但是未更新段映射，这个时候页机制和段机制对于`0xC0000000`的偏移是叠加的。由于上一阶段已经修改过段机制的代码，这里仅需要将`boot_map_segment`函数调用的`KERNBASE`参数改为0，并取消VPT的递归自映射。这种情况下也没有必要专门建立0-4M物理地址映射，因为即使偏移叠加物理地址和虚拟地址还是相等的（最后有更详细的解释）。