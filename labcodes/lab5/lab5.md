# Lab3

## 知识点

本实验涉及到了以下课程上提到的知识点：

1. 用户进程
2. 进程状态模型

本实验涉及的其他知识点：

​  1. COW

OS原理中很重要，但在实验中没有对应上的知识点：

1. 轻量级进程

## 练习0

在复制了lab1-4的代码之后，需要做一些修改，包括：

`trap.c`:

1. `ide_init` 当中设置系统调用的中断门
2. `trap_dispatch` 在TICK_NUM次时钟中断之后，将当前进程的`need_resched`设为1，表明需要调度。

`proc.c`:

1. `alloc_proc` 需要设置新的成员变量，但是由于我使用memset，所以无需修改
2. `do_fork` 需要保证`current->wait_state==0`；进程插入链表，增加进程计数器的操作替换为`set_links`函数，它不仅做了以上两件事，还设置了进程的关系指针。

## 练习1

##### 加载应用程序并执行

需要将trapframe的这些变量初始化：

- tf_cs: 用户态的代码段寄存器，初始化为为USER_CS
- tf_ds, tf_es, tf_fs, tf_gs, tf_ss: 用户态数据段寄存器，初始化为USER_DS
- tf_esp: 用户态栈顶，由于开启了分页，因此只需设置为常数USTACKTOP
- tf_eip: 初始化为elf的入口地址
- tf_eflags: 需要将IF置为1，表明当前在中断中

##### 与答案的区别

与参考答案十分接近，只是我多设置了tf_gs, tf_fs

##### 当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的

详细过程为：

1. 如果在调度函数当中这个应用程序被选中，那么就会调用proc_run，在该函数当中，current（当前进程）被设置为此进程控制结构的指针
2. 加载该进程的内核栈，修改CR3寄存器
3. 由于进程的`context->eip`被设置为`forkret`，调用`switch_to`之后进入`forkret`
4. 随后转入`__trapret`，首先根据当前的trapframe加载通用寄存器和段寄存器，随后使用`iret`指令跳转到用户进程入口，并且切换用户栈、用户态。具体来说，在`iret`之前，栈当中由低到高存放的是eip, cs, eflags, esp, ss, 当处理器发现cs后两位为11（用户态）时，就会将这五个数据都载入寄存器，也就完成了内核态到用户态的切换。

## 练习2

##### 父进程复制自己的内存空间给子进程

根据注释即可实现。

```c
void * kva_src = page2kva(page);  //获取源、目的物理页的虚拟地址
void * kva_dst = page2kva(npage);        
memcpy(kva_dst, kva_src, PGSIZE); //拷贝内容
ret = page_insert(to, npage, start, perm); //设置页表映射
```

##### 与答案的区别

几乎没有区别

##### 如何设计实现“Copy on Write 机制”

`copy_range`：需要将新进程的页面的物理地址指向和旧进程同样的位置，并且将这部分页面设置为只读，这样在对于这部分页面写操作的时候，会产生page fault。

`do_pgfault`：此时异常可能是由于子进程对共享页面进行写操作。在遇到这种情况的时候，需要复制这个页面，将W位设置为1，将子进程对应的逻辑地址映射进行修改，指向复制出来的页面。

## 练习3

##### 理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现

`do_fork`函数：创建进程并初始化的主要函数。主要负责：创建PCB、分配内核栈、拷贝虚拟内存映射关系、设置`trapframe`、维护进程块的相互关系。uCore中为了存储进程之间的关系，使用了兄弟式的指针连接法。父进程存储的子进程指针为最新创建的进程，而子进程拥有兄指针和弟指针，分别指向创建更早和创建更晚的进程。

`do_execve`函数：主要任务是调用`load_icode`函数读取新的ELF文件，设置新的进程入口点，执行新的进程。

`do_wait`函数：有两种模式，一种只等待一个特定的进程（`pid != 0`），另一种等待任意一个进程；如果进程不是僵尸状态，则父进程进入等待状态，请求重新调度，否则销毁处于僵尸状态的子进程PCB。

`do_exit`函数：基本与`do_fork`相反，销毁相应的内存空间、维护进程链表关系、并将进程转换成僵尸状态（但是不释放PCB），最后请求调度器重新调度。

##### 分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的

是通过修改proc->state实现的。

##### 请给出ucore中一个用户态进程的执行状态生命周期图

```
  ?    +- (5) --- RUNNING --------------+
  |    |           A    |               |
  |    |           |    |               |
 (1)   |          (3)  (4)             (7)
  |    |           |    |               |
  V    |           |    V               V
UNINIT -- (2) --> RUNNABLE -- (7) --> ZOMBIE -- (8) --> ?
       |             A                  A
       |             |                  |
       |            (6)                (7)
       |             |                  |
       |             |                  |
       +- (5) --> SLEEPING -------------+
```







