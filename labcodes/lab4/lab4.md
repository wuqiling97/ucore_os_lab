# Lab3

## 知识点

本实验涉及到了以下课程上提到的知识点：

1. 进程的概念
2. 进程控制块，状态模型，进程切换
3. 内核线程

本实验涉及的其他知识点：

​     无

OS原理中很重要，但在实验中没有对应上的知识点：

1. 进程的等待与退出
2. 用户进程

## 练习1

##### 分配并初始化一个进程控制块

需要将这些变量初始化：

- state： 进程状态，初始化为PROC_UNINIT
- pid： 进程号，初始化为-1，防止与idle线程混淆
- runs：进程运行次数，初始化为0
- kstack：内核栈的逻辑地址，初始化为NULL
- need_resched：是否需要调度，不需要
- parent：父进程，初始化为NULL
- mm：虚拟内存管理器，初始化为NULL
- cr3：页表起始地址，初始化为boot_cr3（启动时使用的页表地址）
- flags：进程标志，初始化为0
- name：进程名，需要将其清空

##### 与答案的区别

我是先将整个结构体memset为0，然后再对非零的成员赋值；而答案则是对每一个成员一一赋值。我的实现性能可能会更高，而答案的实现意思更清楚。

##### proc_struct中`struct context context`和`struct trapframe *tf`成员变量含义和在本实验中的作用

context用于进程切换，存储了CPU的寄存器和程序指针，在进程切换、调用`switch_to`的时候用到；trapframe是当前内核栈内存储的，进入中断例程时候用户态的上下文，用于内核态和用户态的转换，在`iret`的时候用到，在设置系统调用返回值或返回地址的时候也可通过更改这个结构体来实现。

由于进程切换处于内核态，故context存储的是内核态的上下文。

## 练习2

##### 为新创建的内核线程分配资源

根据注释即可实现。步骤如下

1. 分配进程控制块
2. 修改控制块的父进程（parent）成员
3. 分配内核的栈空间
4. 拷贝mm_struct，建立地址映射关系
5. 拷贝父进程的trapframe
6. 屏蔽中断，因为时钟中断可能会导致进程调度
7. 建立哈希链表
8. 使能中断
9. 唤醒进程
10. 返回pid

##### 与答案的区别

在禁止，使能中断之间的代码，答案加入了大括号，而我没有加。由于大括号只是隔离了作用域，而外部作用域没有重复的变量，所以应该没有差别。

##### ucore是否做到给每个新fork的线程一个唯一的id

是的。因为在`get_pid`之前已经做了屏蔽中断的处理。此函数是通过遍历进程列表，寻找尚未分配的pid，然后返回来实现的。既然屏蔽了中断，在执行该函数的时候，进程列表就不会改变，所以能够分配唯一的pid。

## 练习3

##### 阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的

proc_run的核心代码如下

```c
current = proc;
load_esp0(next->kstack + KSTACKSIZE);
lcr3(next->cr3);
switch_to(&(prev->context), &(next->context));
```

首先将current进程切换为proc；随后用`load_esp0`将proc的内核esp读取到TSS当中的区域，这使得proc运行的时候，如果需要转到内核态，可以知道内核的esp；`lcr3`将CR3寄存器的值设置为proc的页目录基址；最后调用`switch_to`将proc的上下文读取到CPU当中。至此proc_run就完成了进程切换。

##### 在本实验的执行过程中，创建且运行了几个内核线程

2个，分别是idle和init。idle是一个循环，不断调用`schedule`，内核在没有其他进程可以运行的时候会运行idle。init目前只是打印了字符串。

进入qemu之后，首先是idle运行，随后init运行。

##### 语句`local_intr_save(intr_flag);....local_intr_restore(intr_flag);`在这里有何作用

 屏蔽中断，保证在进行重要操作的时候不会被打断，也就是保证如下操作是原子操作：切换进程，创建进程（主要是设置哈希表部分）等











